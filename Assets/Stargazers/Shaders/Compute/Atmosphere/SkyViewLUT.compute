// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

/*
implementation of the Hillaire 2020 atmosphere skyview look up table 
based on the following implementations: by 
Kevin Sawatzky (https://github.com/ksawatzky777/Strontium/blob/main/assets/shaders/compute/sky/multiscatCompute.srshader)
and Andrew Helmer (https://www.shadertoy.com/view/slSXRW) 
*/

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

//the transmittance look up table
Texture2D<float4> transLut;
//the multiscattering lookup table
Texture2D<float4> multiscatLut;
SamplerState LinearClampSampler;

//texture data
float2 TextureResolution;

//planet data
float groundRadius;
float atmosphereRadius;
float g;
float scale;
float3 albedo;

//scene data
float3 sunDirection;
float3 viewPos;

// Scattering data
//w or a component is used for height falloff and scale
float4 rayleighScattering;
float4 rayleighAbsorb;
float4 mieScattering;
float4 mieAbsorb;
float4 ozoneAbsorb;

//settings
const int STEPS = 32;
const float PI = 3.141592654;

//check if a ray is intersecting a sphere and by how much
float raySphereIntersect(float3 rayOrigin, float3 rayDirection, float rad)
{
	//tbh I don't really understand how this math works
    float b = dot(rayOrigin, rayDirection);
    float c = dot(rayOrigin, rayOrigin) - rad * rad;

    float result = 0.0;

    float discrimnate = b * b - c;

	//used to determine which of the four possible outputs should be returned
	//special case is when inside the sphere and we need to use the far discriminant
    int specialCase = ((discrimnate > b * b) ? 1 : 0);
    int negativeOne = (((c > 0.0 && b > 0.0) || discrimnate < 0.0) ? 1 : 0);

	//if it's the special case, set result to the special case, otherwise set it to the normal case
    result = lerp((-b - sqrt(discrimnate)), (-b + sqrt(discrimnate)), specialCase);
	//check if it should be negative one, if it is, set result to that, otherwise keep the value from the above lerp
    result = lerp(result, -1.0, negativeOne);

	//return the result
    return result;
}

//function that calculates the ammount of light that is being either absorbed or scattered away at a given point
float3 computeExtinction(float3 pos)
{
    float altitude = (length(pos) * groundRadius) * 1000.0;

    float rayleighDensity = exp(-altitude / rayleighScattering.w);
    float mieDensity = exp(-altitude / mieScattering.w);
	
    float3 rayleighScat = rayleighScattering.rgb * rayleighDensity;
    float3 mieScat = mieScattering.rgb * mieDensity;

    float3 rayAbsorbtion = rayleighAbsorb.rgb * rayleighDensity;
    float3 mieAbsorbtion = mieAbsorb.rgb * mieDensity;
    float3 ozoneAbsorbtion = ozoneAbsorb.rgb * ozoneAbsorb.w * max(0.0, 1.0 - abs(altitude - 25.0) / 15.0);

    return rayleighScat + rayAbsorbtion + mieScat + mieAbsorbtion + ozoneAbsorbtion;
}

//function to sample the transmittance lut 
float3 sampleLUT(Texture2D lut, float3 pos, float3 sunDir)
{
    float height = length(pos);
    float3 up = pos / height;
    
    float sunCosZenithAngle = dot(sunDir, up);
    
    float2 uvs = float2(
        clamp(0.5 + 0.5 * sunCosZenithAngle, 0.0, 1.0),
        max(0.0, min(1.0, (height * groundRadius) / (atmosphereRadius - groundRadius)))
    );

    return lut.SampleLevel(LinearClampSampler, uvs, 0).rgb;
}

//get the mie particle phase value
float calcMiePhase(float cosTheta)
{
    float numerator = (1.0 - g * g) * (1.0 + cosTheta * cosTheta);
    float denominator = (2.0 + g * g) * pow(abs((1.0 + g * g - 2.0 * g * cosTheta)), 1.5);
    
    return scale * numerator / denominator;
}

//get the rayleigh particle phase value
float calcRayleighPhase(float cosTheta)
{
    float K = 3.0 / (16.0 * PI);
    return K * (1.0 + cosTheta * cosTheta);
}

//do a single instance of the scattering integral
float3 raymarchScatter(float3 pos, float3 rayDir, float3 sunDir, float maxDistance)
{
    float cosTheta = dot(rayDir, sunDir);
    float miePhaseValue = calcMiePhase(cosTheta);
    float raylieghtPhaseValue = calcRayleighPhase(-cosTheta);
    
    //raymarching
    float3 lum = float3(0.0, 0.0, 0.0);
    float3 transmittance = float3(1.0, 1.0, 1.0);
    float t = 0.0;
    for (int i = 0; i < STEPS; i++)
    {
        float newT = ((float(i) + 0.3) / float(STEPS)) * maxDistance;
        float dt = newT - t;
        t = newT;

        float3 newPos = pos + t * rayDir;
        
        float altitude = (length(newPos) - groundRadius) * 1000.0;
        float rayleighDensity = exp(-altitude / rayleighScattering.w);
        float mieDensity = exp(-altitude / mieScattering.w);
        
        float3 rayleighScat = rayleighScattering.rgb * rayleighDensity;
        float3 mieScat = mieScattering.rbg * mieDensity;
        
        float3 extinction = computeExtinction(newPos);
        float3 sampleTransmittance = exp(-dt * extinction);
        
        float3 sunTransmittance = sampleLUT(transLut, newPos, sunDir);
        float3 psi = sampleLUT(multiscatLut, newPos, sunDir);
        
        float3 rayleighInScattering = rayleighScat * (raylieghtPhaseValue * sunTransmittance + psi);
        float3 mieInScattering = mieScat * (miePhaseValue * sunTransmittance + psi);
        float3 inScattering = rayleighInScattering + mieInScattering;
        
        //integrate
        float3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;
        lum += scatteringIntegral * transmittance;
        transmittance *= sampleTransmittance;
    }

    return lum;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //base uvs
    float2 uvs = float2((0.5 + id.x) / TextureResolution.x, (0.5 + id.y) / TextureResolution.y);
    
    //figuring out the non-linear parameterization while also calculating the scattering details we need
    float azimuthAngle = 2.0 * PI * (uvs.x - 0.5);
    float coord = lerp(2.0 * uvs.y - 1.0, 1.0 - 2.0 * uvs.y, int(uvs.y < 0.5));
    float adjV = lerp(coord * coord, -(coord * coord), int(uvs.y < 0.5));
    
    float height = length(viewPos);
    float3 up = viewPos / height;
    float horizonAngle = acos(clamp(sqrt(height * height - groundRadius * groundRadius) / height, 0.0, 1.0)) - 0.5 * PI;
    float altitudeAngle = adjV * 0.5 * PI - horizonAngle;
    float3 rayDir = normalize(float3(cos(altitudeAngle) * sin(azimuthAngle), sin(altitudeAngle), -cos(altitudeAngle) * cos(azimuthAngle)));
    
    float sunAltitude = (0.5 * PI) - acos(dot(normalize(sunDirection), up));
    float3 newSunDir = normalize(float3(0.0, sin(sunAltitude), -cos(sunAltitude)));
    
    float atmoDist = raySphereIntersect(viewPos, rayDir, atmosphereRadius);
    float groundDist = raySphereIntersect(viewPos, rayDir, groundRadius);
    float maxDist = lerp(groundDist, atmoDist, int(groundDist < 0.0));
    
    //do a single scattering raymarch and related integration saving the result to the texture
    //need to change this to do a check for if it should be using the viewPos or a point on the edge of the atmosphere
    float3 result = raymarchScatter(viewPos, rayDir, newSunDir, maxDist);

    Result[id.xy] = float4(result, 1.0);
}
