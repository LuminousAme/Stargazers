// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

/*
implementation of the Hillaire 2020 atmosphere skyview look up table 
based on the following implementations: by 
Kevin Sawatzky (https://github.com/ksawatzky777/Strontium/blob/main/assets/shaders/compute/sky/multiscatCompute.srshader)
and Andrew Helmer (https://www.shadertoy.com/view/slSXRW) 
*/

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

//the transmittance look up table
Texture2D<float4> transLut;
//the multiscattering lookup table
Texture2D<float4> multiscatLut;
SamplerState LinearClampSampler;

//texture data
float2 TextureResolution;

//planet data
float groundRadius;
float atmosphereRadius;
float g;
float scale;

//scene data
float3 sunDirection;
float3 viewPos;

// Scattering data
//w or a component is used for height falloff and scale
float4 rayleighScattering;
float4 rayleighAbsorb;
float4 mieScattering;
float4 mieAbsorb;
float4 ozoneAbsorb;

//settings
static const float STEPS = 32.0;
static const float PLANET_OFFSET = 1e-3;
static const float PI = 3.141592654;

//check if a ray is intersecting a sphere and by how much
float raySphereIntersect(float3 rayOrigin, float3 rayDirection, float rad)
{
    float b = dot(rayOrigin, rayDirection);
    float c = dot(rayOrigin, rayOrigin) - rad * rad;

    float result = 0.0;

    float discrimnate = b * b - c;

	//if it's the special case, set result to the special case, otherwise set it to the normal case
    result = (discrimnate > b * b) ? (-b + sqrt(discrimnate)) : (-b - sqrt(discrimnate));
	//check if it should be negative one, if it is, set result to that, otherwise keep the value from the above
    result = ((c > 0.0 && b > 0.0) || discrimnate < 0.0) ? -1.0 : result;

	//return the result
    return result;
}

float2 raySphereIntsect2(float3 rayOrigin, float3 rayDir, float3 spherePosition, float rad)
{
    float3 offset = rayOrigin - spherePosition;

    float a = dot(rayDir, rayDir);
    float b = 2 * dot(offset, rayDir);
    float c = dot(offset, offset) - (rad * rad);
    float discrim = b * b - 4 * a * c;

    float s = sqrt(discrim);
    float nearDist = max(0, (-b - s) / (2.0 * a));
    float farDist = (-b + s) / (2.0 * a);

    int failed = int(discrim <= 0.0 || farDist < 0.0);
    float2 result = lerp(float2(nearDist, farDist - nearDist), float2(1e36, 0), failed);
    return result;

    return float2(1e36, 0);
}

//function that calculates the ammount of light that is being either absorbed or scattered away at a given point
float3 computeExtinction(float3 pos)
{
    float altitude = (length(pos) - groundRadius) * 1000.0;

    float rayleighDensity = exp(-altitude / rayleighScattering.w);
    float mieDensity = exp(-altitude / mieScattering.w);
	
    float3 rayleighScat = rayleighScattering.rgb * rayleighDensity;
    float3 mieScat = mieScattering.rgb * mieDensity;

    float3 rayAbsorbtion = rayleighAbsorb.rgb * rayleighDensity;
    float3 mieAbsorbtion = mieAbsorb.rgb * mieDensity;
    float3 ozoneAbsorbtion = ozoneAbsorb.rgb * ozoneAbsorb.w * max(0.0, 1.0 - abs(altitude - 25.0) / 15.0);

    return rayleighScat + rayAbsorbtion + mieScat + mieAbsorbtion + ozoneAbsorbtion;
}

float3 computeRayleightScat(float3 pos)
{
    float altitude = (length(pos) - groundRadius) * 1000.0;
    float rayleighDensity = exp(-altitude / rayleighScattering.w);
    return rayleighScattering.rgb * rayleighDensity;
}

float3 computeMieScat(float3 pos)
{
    float altitude = (length(pos) - groundRadius) * 1000.0;
    float mieDensity = exp(-altitude / mieScattering.w);
    return mieScattering.rgb * mieDensity;
}

//function to sample the transmittance lut 
float3 sampleLUT(Texture2D lut, float3 pos, float3 sunDir)
{
    float height = length(pos);
    float3 up = pos / height;
    
    float sunCosZenithAngle = dot(sunDir, up);
    
    float2 uvs = float2(
        clamp(0.5 + 0.5 * sunCosZenithAngle, 0.0, 1.0),
        max(0.0, min(1.0, (height - groundRadius) / (atmosphereRadius - groundRadius)))
    );

    return lut.SampleLevel(LinearClampSampler, uvs, 0).rgb;
}

//get the mie particle phase value
float calcMiePhase(float cosTheta)
{
    float numerator = (1.0 - g * g) * (1.0 + cosTheta * cosTheta);
    float denominator = (2.0 + g * g) * pow(abs((1.0 + g * g - 2.0 * g * cosTheta)), 1.5);
    
    return scale * numerator / denominator;
}

//get the rayleigh particle phase value
float calcRayleighPhase(float cosTheta)
{
    float K = 3.0 / (16.0 * PI);
    return K * (1.0 + cosTheta * cosTheta);
}

float InverseLerp(float a, float b, float value)
{
    return (value - a) / (b - a);
}

//do a single instance of the scattering integral
float3 raymarchScatter(float3 pos, float3 rayDir, float3 sunDir, float maxDistance)
{
    float cosTheta = dot(rayDir, sunDir);
    float miePhaseValue = calcMiePhase(cosTheta);
    float raylieghtPhaseValue = calcRayleighPhase(-cosTheta);
    
    //raymarching
    float3 lum = float3(0.0, 0.0, 0.0);
    float3 transmittance = float3(1.0, 1.0, 1.0);
    float t = 0.0;
    for (float i = 0.0; i < STEPS; i+= 1.0)
    {
        float newT = ((i + 0.3) / STEPS) * maxDistance;
        float dt = newT - t;
        t = newT;
       
        float3 newPos = pos + rayDir * t; //seems something is going wrong with this value
        
        float3 rayleighScat = computeRayleightScat(newPos);
        float3 mieScat = computeMieScat(newPos);
        
        float3 extinction = computeExtinction(newPos);
        
        float3 sampleTransmittance = exp(-dt * extinction);
        
        float3 sunTransmittance = sampleLUT(transLut, newPos, sunDir);
        float3 psi = sampleLUT(multiscatLut, newPos, sunDir);
        
        float3 rayleighInScattering = rayleighScat * (raylieghtPhaseValue * sunTransmittance + psi);
        float3 mieInScattering = mieScat * (miePhaseValue * sunTransmittance + psi);
        float3 inScattering = rayleighInScattering + mieInScattering;
        
        //integrate
        float3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;
        lum += scatteringIntegral * transmittance;
        transmittance *= sampleTransmittance;
    }
    
    return lum;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //base uvs
    float2 uvs = float2((0.5 + id.x) / TextureResolution.x, (0.5 + id.y) / TextureResolution.y);
    
    //figuring out the non-linear parameterization while also calculating the scattering details we need
    float azimuthAngle = 2.0 * PI * (uvs.x - 0.5);
    float coord = (uvs.y < 0.5) ? 1.0 - 2.0 * uvs.y : 2.0 * uvs.y - 1.0;
    float adjV = (uvs.y < 0.5) ? -(coord * coord) : coord * coord;
    
    float height = length(viewPos);
    float3 up = viewPos / height;
    float horizonAngle = acos(clamp(sqrt(height * height - groundRadius * groundRadius) / height, 0.0, 1.0)) - 0.5 * PI;
    float altitudeAngle = adjV * 0.5 * PI - horizonAngle;
    float3 rayDir = normalize(float3(cos(altitudeAngle) * sin(azimuthAngle), sin(altitudeAngle), -cos(altitudeAngle) * cos(azimuthAngle)));
    
    float sunAltitude = (0.5 * PI) - acos(dot(normalize(sunDirection), up));
    float3 newSunDir = normalize(float3(0.0, sin(sunAltitude), -cos(sunAltitude)));
    
    //handling views outside of the atmosphere
    /*
    float atmoEdge = raySphereIntersect(viewPos, rayDir, atmosphereRadius);
    bool outOfAtmo = height >= atmosphereRadius;
    float3 upOffset = up * -PLANET_OFFSET;
    float3 newViewPos = (outOfAtmo && atmoEdge >= 0.0) ? viewPos + atmoEdge * rayDir + upOffset : viewPos;*/
    float atmoEdge = raySphereIntersect(viewPos, rayDir, atmosphereRadius);
    bool outOfAtmo = height >= atmosphereRadius;
    float3 upOffset = up * -PLANET_OFFSET;
    float3 newViewPos = (outOfAtmo && atmoEdge >= 0.0) ? viewPos + atmoEdge * rayDir + upOffset : viewPos;
    
    float atmoDist = raySphereIntersect(newViewPos, rayDir, atmosphereRadius);
    float groundDist = raySphereIntersect(newViewPos, rayDir, groundRadius);
    float maxDist = (groundDist < 0.0) ? atmoDist : groundDist;
    
    float3 result = float3(0.0, 0.0, 0.0);
    if (!(outOfAtmo && atmoEdge < 0.0))
    {
        //do a single scattering raymarch and related integration saving the result to the texture
        result = raymarchScatter(newViewPos, rayDir, newSunDir, maxDist);
    }
    
    //do not use the result if the ray did not intersect with the atmoshpere at all
    //result = (outOfAtmo && atmoEdge < 0.0) ? float3(0.0, 0.0, 0.0) : result;
    
    float3 blep = (atmoEdge < 0.0) ? float3(1.0, 1.0, 1.0) : float3(0.0, 0.0, 0.0);
    //float3 blep = (outOfAtmo) ? float3(1.0, 1.0, 1.0) : float3(0.0, 0.0, 0.0);
    //blep = atmosphereRadius - groundRadius;
    Result[id.xy] = float4(result, 1.0);
}
